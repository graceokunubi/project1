<html>

    <head>
        <title> Donald Trump 2020 Approval Ratings by Pollster </title>
        <script src="https://d3js.org/d3.v6.min.js"></script>
        <style>

          .legend span {
            margin-right: 10px;
          }

          .gridlines line {
            stroke: #DEDEDE;
          }

        </style>
    </head>

    <body>
      <svg id="scatterplot" height="400" width="800">
        //making a big chart because we have a lot of data
      </svg>

      <div id="scatterLegend" class="legend"> </div>

      <script>

        var data;
        const svg = d3.select("svg#scatterplot");
        const width = svg.attr("width");
        const height = svg.attr("height");
        const margins = {"top": 10, "right": 10, "bottom": 20, "left": 30};
          //margins are subject to change later
        const chartWidth = width - margins.left - margins.right;
        const chartHeight = height - margins.top - margins.bottom;


        let annotations = svg.append("g").attr("id","annotations");
        let chartArea = svg.append("g").attr("id","points")
                    .attr("transform","translate("+margins.left+","+margins.top+")");

        // var borderPath = svg.append("rect")
        //  .attr("x", 30)
        //  .attr("y", 10)
        //  .attr("height", 370)
        //  .attr("width", 760)
        //  .style("stroke","black")
        //  .style("fill", "none")
        //  .style("stroke-width","1px");


        d3.json("./approval_polllist.json", d3.autoType)
            .then( (data) => {

                console.log(data);

                //string date format 1/23/2017
                const dateParser = d3.timeParse("%m/%d/%Y");
                data.forEach( d => {
                    d['createddate'] = dateParser(d["createddate"]);
                    d['enddate'] = dateParser(d["enddate"]); //we can use this date as the proxy date for the visualization
                    d['modeldate'] = dateParser(d["modeldate"]); //seems to be date when data model created; probably irrelevant
                    d['startdate'] = dateParser(d["startdate"]);
                });

                data = data.filter( (d) => {return (d['enddate'] >= new Date("1/1/2020")) && (d['enddate'] < new Date("1/1/2021")) ;}  );
                data.sort( (a,b) => d3.ascending(a['enddate'], b['enddate']));

                console.log(data);

                const dateExtent = d3.extent(data, d => d['enddate'] );
                //I can't remember if we decided on using enddate or startdate but this can be easily changed
                //console.log(dateExtent);
                const dateScale = d3.scaleLinear().domain(['1/1/2020','12/31/2020']).range([0,chartWidth]);
                const approveExtent = d3.extent(data, d => d['adjusted_approve'] );
                const disapproveExtent = d3.extent(data, d => d['adjusted_disapprove']);
                //console.log(approveExtent);
                //console.log(disapproveExtent);
                const scoreScale = d3.scaleLinear().domain([-70,70])
                                     .range([chartHeight, 0]);
                                     //domain based on largest disapproval and approval

                let leftAxis = d3.axisLeft(scoreScale)
                                  .tickFormat(d3.format("~f"))
                                  .ticks(12);
                let leftGridlines = d3.axisLeft(scoreScale)
                                      .tickSize(-chartWidth)
                                      .tickFormat("")
                                      .ticks(12);

                annotations.append("g")
                  .attr("class", "y axis")
                  .attr("transform","translate("+(margins.left)+","+(margins.top)+")")
                  .call(leftAxis);
                annotations.append("g")
                  .attr("class", "y gridlines")
                  .attr("transform","translate("+(margins.left)+","+margins.top+")")
                  .call(leftGridlines);

                let bottomAxis = d3.axisBottom(dateScale)
                                   .tickFormat(d3.timeFormat("%m/%d"))
                                   .ticks(11);
                let bottomGridlines = d3.axisBottom(dateScale)
                                        .tickSize(-chartHeight)
                                        .tickFormat("")
                                        .ticks(11);

                annotations.append("g")
                  .attr("class", "x axis")
                  .attr("transform","translate("+margins.left+","+(chartHeight/2+margins.top)+")")
                  .call(bottomAxis);

                annotations.append("g")
                  .attr("class", "x gridlines")
                  .attr("transform","translate("+margins.left+","+(chartHeight+margins.top)+")")
                  .call(bottomGridlines);


                

        });

      </script>
    </body>

</html>
